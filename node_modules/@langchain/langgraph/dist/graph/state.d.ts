import { Runnable, RunnableConfig, RunnableLike } from "@langchain/core/runnables";
import { BaseChannel } from "../channels/base.js";
import { BinaryOperator, BinaryOperatorAggregate } from "../channels/binop.js";
import { END, CompiledGraph, Graph, START, Branch } from "./graph.js";
import { LastValue } from "../channels/last_value.js";
import { BaseCheckpointSaver } from "../checkpoint/base.js";
import { All } from "../pregel/types.js";
export declare function Annotation<ValueType>(): LastValue<ValueType>;
export declare function Annotation<ValueType, UpdateType = ValueType>(annotation: SingleReducer<ValueType, UpdateType>): BinaryOperatorAggregate<ValueType, UpdateType>;
interface StateDefinition {
    [key: string]: BaseChannel | (() => BaseChannel);
}
type ExtractValueType<C> = C extends BaseChannel ? C["ValueType"] : C extends () => BaseChannel ? ReturnType<C>["ValueType"] : never;
type ExtractUpdateType<C> = C extends BaseChannel ? C["UpdateType"] : C extends () => BaseChannel ? ReturnType<C>["UpdateType"] : never;
export type StateInterface<S extends StateDefinition> = {
    [key in keyof S]: ExtractValueType<S[key]>;
};
export type UpdateInterface<S extends StateDefinition> = {
    [key in keyof S]?: ExtractUpdateType<S[key]>;
};
type SingleReducer<ValueType, UpdateType = ValueType> = {
    reducer: BinaryOperator<ValueType, UpdateType>;
    default?: () => ValueType;
} | {
    /**
     * @deprecated Use `reducer` instead
     */
    value: BinaryOperator<ValueType, UpdateType>;
    default?: () => ValueType;
} | null;
export type ChannelReducers<Channels extends object> = {
    [K in keyof Channels]: SingleReducer<Channels[K], any>;
};
export interface StateGraphArgs<Channels extends object | unknown> {
    channels: Channels extends object ? Channels extends unknown[] ? ChannelReducers<{
        __root__: Channels;
    }> : ChannelReducers<Channels> : ChannelReducers<{
        __root__: Channels;
    }>;
}
export declare class StateGraph<SD extends StateDefinition | unknown, S = SD extends StateDefinition ? StateInterface<SD> : SD, U = SD extends StateDefinition ? UpdateInterface<SD> : Partial<S>, N extends string = typeof START> extends Graph<N, S, U> {
    channels: Record<string, BaseChannel>;
    waitingEdges: Set<[N[], N]>;
    constructor(fields: SD extends StateDefinition ? SD | StateGraphArgs<S> : StateGraphArgs<S>);
    get allEdges(): Set<[string, string]>;
    addNode<K extends string>(key: K, action: RunnableLike<S, U>): StateGraph<SD, S, U, N | K>;
    addEdge(startKey: typeof START | N | N[], endKey: N | typeof END): this;
    compile({ checkpointer, interruptBefore, interruptAfter, }?: {
        checkpointer?: BaseCheckpointSaver;
        interruptBefore?: N[] | All;
        interruptAfter?: N[] | All;
    }): CompiledStateGraph<S, U, N>;
}
export declare class CompiledStateGraph<S, U, N extends string = typeof START> extends CompiledGraph<N, S, U> {
    builder: StateGraph<unknown, S, U, N>;
    attachNode(key: typeof START, node?: never): void;
    attachNode(key: N, node: Runnable<S, U, RunnableConfig>): void;
    attachEdge(start: N | N[] | "__start__", end: N | "__end__"): void;
    attachBranch(start: N | typeof START, name: string, branch: Branch<S, N>): void;
}
export {};
