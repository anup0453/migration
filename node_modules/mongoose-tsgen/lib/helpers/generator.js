"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.saveFile = exports.generateTypes = exports.getSchemaTypes = exports.parseFunctions = exports.createSourceFile = exports.overloadQueryPopulate = exports.addPopulateHelpers = exports.replaceModelTypes = void 0;
const tslib_1 = require("tslib");
const ts_morph_1 = require("ts-morph");
const templates = (0, tslib_1.__importStar)(require("./templates"));
const schema_1 = require("../parser/schema");
const utils_1 = require("../parser/utils");
const stringBuilder_1 = require("../writer/stringBuilder");
// TODO next: Pull this file apart. Create a new "file writer" file, move all the ts stuff somewhere else,
// this strips comments of special tokens since ts-morph generates jsdoc tokens automatically
const cleanComment = (comment) => {
    return comment
        .replace(/^\/\*\*[^\S\r\n]?/, "")
        .replace(/[^\S\r\n]+\*\s/g, "")
        .replace(/(\n)?[^\S\r\n]+\*\/$/, "");
};
const convertFuncSignatureToType = (funcSignature, funcType, modelName) => {
    var _a;
    const [, params, returnType] = (_a = funcSignature.match(/\((?:this: \w*(?:, )?)?(.*)\) => (.*)/)) !== null && _a !== void 0 ? _a : [];
    let type;
    if (funcType === "query") {
        type = `(this: ${modelName}Query${(params === null || params === void 0 ? void 0 : params.length) > 0 ? ", " + params : ""}) => ${modelName}Query`;
    }
    else if (funcType === "methods") {
        type = `(this: ${modelName}Document${(params === null || params === void 0 ? void 0 : params.length) > 0 ? ", " + params : ""}) => ${returnType !== null && returnType !== void 0 ? returnType : "any"}`;
    }
    else {
        type = `(this: ${modelName}Model${(params === null || params === void 0 ? void 0 : params.length) > 0 ? ", " + params : ""}) => ${returnType !== null && returnType !== void 0 ? returnType : "any"}`;
    }
    return type;
};
const replaceModelTypes = (sourceFile, modelTypes, models) => {
    Object.entries(modelTypes).forEach(([modelName, types]) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
        const { methods, statics, query, virtuals, comments } = types;
        // methods
        if (Object.keys(methods).length > 0) {
            (_b = (_a = sourceFile === null || sourceFile === void 0 ? void 0 : sourceFile.getTypeAlias(`${modelName}Methods`)) === null || _a === void 0 ? void 0 : _a.getFirstChildByKind(ts_morph_1.SyntaxKind.TypeLiteral)) === null || _b === void 0 ? void 0 : _b.getChildrenOfKind(ts_morph_1.SyntaxKind.PropertySignature).forEach((prop) => {
                const signature = methods[prop.getName()];
                if (signature) {
                    const funcType = convertFuncSignatureToType(signature, "methods", modelName);
                    prop.setType(funcType);
                }
            });
        }
        // statics
        if (Object.keys(statics).length > 0) {
            (_d = (_c = sourceFile === null || sourceFile === void 0 ? void 0 : sourceFile.getTypeAlias(`${modelName}Statics`)) === null || _c === void 0 ? void 0 : _c.getFirstChildByKind(ts_morph_1.SyntaxKind.TypeLiteral)) === null || _d === void 0 ? void 0 : _d.getChildrenOfKind(ts_morph_1.SyntaxKind.PropertySignature).forEach((prop) => {
                const signature = statics[prop.getName()];
                if (signature) {
                    const funcType = convertFuncSignatureToType(signature, "statics", modelName);
                    prop.setType(funcType);
                }
            });
        }
        // queries
        if (Object.keys(query).length > 0) {
            (_f = (_e = sourceFile === null || sourceFile === void 0 ? void 0 : sourceFile.getTypeAlias(`${modelName}Queries`)) === null || _e === void 0 ? void 0 : _e.getFirstChildByKind(ts_morph_1.SyntaxKind.TypeLiteral)) === null || _f === void 0 ? void 0 : _f.getChildrenOfKind(ts_morph_1.SyntaxKind.PropertySignature).forEach((prop) => {
                const signature = query[prop.getName()];
                if (signature) {
                    const funcType = convertFuncSignatureToType(signature, "query", modelName);
                    prop.setType(funcType);
                }
            });
        }
        // virtuals
        const virtualNames = Object.keys(virtuals);
        if (virtualNames.length > 0) {
            const documentProperties = (_j = (_h = (_g = sourceFile === null || sourceFile === void 0 ? void 0 : sourceFile.getTypeAlias(`${modelName}Document`)) === null || _g === void 0 ? void 0 : _g.getFirstChildByKind(ts_morph_1.SyntaxKind.IntersectionType)) === null || _h === void 0 ? void 0 : _h.getFirstChildByKind(ts_morph_1.SyntaxKind.TypeLiteral)) === null || _j === void 0 ? void 0 : _j.getChildrenOfKind(ts_morph_1.SyntaxKind.PropertySignature);
            const { schema } = models.find((model) => model.modelName === modelName);
            const leanProperties = (0, utils_1.getShouldLeanIncludeVirtuals)(schema) &&
                ((_l = (_k = sourceFile === null || sourceFile === void 0 ? void 0 : sourceFile.getTypeAlias(`${modelName}`)) === null || _k === void 0 ? void 0 : _k.getFirstChildByKind(ts_morph_1.SyntaxKind.TypeLiteral)) === null || _l === void 0 ? void 0 : _l.getChildrenOfKind(ts_morph_1.SyntaxKind.PropertySignature));
            if (documentProperties || leanProperties) {
                virtualNames.forEach((virtualName) => {
                    const virtualNameComponents = virtualName.split(".");
                    let nestedDocProps;
                    let nestedLeanProps;
                    virtualNameComponents.forEach((nameComponent, i) => {
                        var _a, _b, _c, _d;
                        if (i === virtualNameComponents.length - 1) {
                            if (documentProperties) {
                                const docPropMatch = (nestedDocProps !== null && nestedDocProps !== void 0 ? nestedDocProps : documentProperties).find((prop) => prop.getName() === nameComponent);
                                docPropMatch === null || docPropMatch === void 0 ? void 0 : docPropMatch.setType(virtuals[virtualName]);
                            }
                            if (leanProperties) {
                                const leanPropMatch = (nestedLeanProps !== null && nestedLeanProps !== void 0 ? nestedLeanProps : leanProperties).find((prop) => prop.getName() === nameComponent);
                                leanPropMatch === null || leanPropMatch === void 0 ? void 0 : leanPropMatch.setType(virtuals[virtualName]);
                            }
                            return;
                        }
                        if (documentProperties) {
                            nestedDocProps = (_b = (_a = (nestedDocProps !== null && nestedDocProps !== void 0 ? nestedDocProps : documentProperties)
                                .find((prop) => prop.getName() === nameComponent)) === null || _a === void 0 ? void 0 : _a.getFirstChildByKind(ts_morph_1.SyntaxKind.TypeLiteral)) === null || _b === void 0 ? void 0 : _b.getChildrenOfKind(ts_morph_1.SyntaxKind.PropertySignature);
                        }
                        if (leanProperties) {
                            nestedLeanProps = (_d = (_c = (nestedLeanProps !== null && nestedLeanProps !== void 0 ? nestedLeanProps : leanProperties)
                                .find((prop) => prop.getName() === nameComponent)) === null || _c === void 0 ? void 0 : _c.getFirstChildByKind(ts_morph_1.SyntaxKind.TypeLiteral)) === null || _d === void 0 ? void 0 : _d.getChildrenOfKind(ts_morph_1.SyntaxKind.PropertySignature);
                        }
                    });
                });
            }
        }
        // TODO: this section is almost identical to the virtual property section above, refactor
        if (comments.length > 0) {
            const documentProperties = (_p = (_o = (_m = sourceFile === null || sourceFile === void 0 ? void 0 : sourceFile.getTypeAlias(`${modelName}Document`)) === null || _m === void 0 ? void 0 : _m.getFirstChildByKind(ts_morph_1.SyntaxKind.IntersectionType)) === null || _o === void 0 ? void 0 : _o.getFirstChildByKind(ts_morph_1.SyntaxKind.TypeLiteral)) === null || _p === void 0 ? void 0 : _p.getChildrenOfKind(ts_morph_1.SyntaxKind.PropertySignature);
            const leanProperties = (_r = (_q = sourceFile === null || sourceFile === void 0 ? void 0 : sourceFile.getTypeAlias(`${modelName}`)) === null || _q === void 0 ? void 0 : _q.getFirstChildByKind(ts_morph_1.SyntaxKind.TypeLiteral)) === null || _r === void 0 ? void 0 : _r.getChildrenOfKind(ts_morph_1.SyntaxKind.PropertySignature);
            comments.forEach(({ path, comment }) => {
                const pathComponents = path.split(".");
                let nestedDocProps;
                let nestedLeanProps;
                pathComponents.forEach((nameComponent, i) => {
                    var _a, _b, _c, _d;
                    if (i === pathComponents.length - 1) {
                        if (documentProperties) {
                            const docPropMatch = (nestedDocProps !== null && nestedDocProps !== void 0 ? nestedDocProps : documentProperties).find((prop) => prop.getName() === nameComponent);
                            docPropMatch === null || docPropMatch === void 0 ? void 0 : docPropMatch.addJsDoc(cleanComment(comment));
                        }
                        if (leanProperties) {
                            const leanPropMatch = (nestedLeanProps !== null && nestedLeanProps !== void 0 ? nestedLeanProps : leanProperties).find((prop) => prop.getName() === nameComponent);
                            leanPropMatch === null || leanPropMatch === void 0 ? void 0 : leanPropMatch.addJsDoc(cleanComment(comment));
                        }
                        return;
                    }
                    if (documentProperties) {
                        nestedDocProps = (_b = (_a = (nestedDocProps !== null && nestedDocProps !== void 0 ? nestedDocProps : documentProperties)
                            .find((prop) => prop.getName() === nameComponent)) === null || _a === void 0 ? void 0 : _a.getFirstChildByKind(ts_morph_1.SyntaxKind.TypeLiteral)) === null || _b === void 0 ? void 0 : _b.getChildrenOfKind(ts_morph_1.SyntaxKind.PropertySignature);
                    }
                    if (leanProperties) {
                        nestedLeanProps = (_d = (_c = (nestedLeanProps !== null && nestedLeanProps !== void 0 ? nestedLeanProps : leanProperties)
                            .find((prop) => prop.getName() === nameComponent)) === null || _c === void 0 ? void 0 : _c.getFirstChildByKind(ts_morph_1.SyntaxKind.TypeLiteral)) === null || _d === void 0 ? void 0 : _d.getChildrenOfKind(ts_morph_1.SyntaxKind.PropertySignature);
                    }
                });
            });
        }
    });
};
exports.replaceModelTypes = replaceModelTypes;
const addPopulateHelpers = (sourceFile) => {
    sourceFile.addStatements("\n" + templates.POPULATE_HELPERS);
};
exports.addPopulateHelpers = addPopulateHelpers;
const overloadQueryPopulate = (sourceFile) => {
    sourceFile.addStatements("\n" + templates.QUERY_POPULATE);
};
exports.overloadQueryPopulate = overloadQueryPopulate;
const createSourceFile = (genPath) => {
    const project = new ts_morph_1.Project();
    const sourceFile = project.createSourceFile(genPath, "", { overwrite: true });
    return sourceFile;
};
exports.createSourceFile = createSourceFile;
// TODO: statics, query, methods should all be parsed in the parser, and then written in the stringBuilder
const parseFunctions = (funcs, modelName, funcType) => {
    let interfaceString = "";
    Object.keys(funcs).forEach((key) => {
        if (["initializeTimestamps"].includes(key))
            return;
        const funcSignature = "(...args: any[]) => any";
        const type = convertFuncSignatureToType(funcSignature, funcType, modelName);
        interfaceString += (0, stringBuilder_1.convertKeyValueToLine)({ key, valueType: type });
    });
    return interfaceString;
};
exports.parseFunctions = parseFunctions;
const getSchemaTypes = (model) => {
    var _a;
    const { modelName, schema } = model;
    let schemaTypes = "";
    // add type alias to modelName so that it can be imported without clashing with the mongoose model
    schemaTypes += templates.getObjectDocs(modelName);
    schemaTypes += `\nexport type ${modelName}Object = ${modelName}\n\n`;
    schemaTypes += templates.getQueryDocs();
    schemaTypes += `\nexport type ${modelName}Query = mongoose.Query<any, ${modelName}Document, ${modelName}Queries> & ${modelName}Queries\n\n`;
    schemaTypes += templates.getQueryHelpersDocs(modelName);
    schemaTypes += `\nexport type ${modelName}Queries = {\n`;
    schemaTypes += (0, exports.parseFunctions)((_a = schema.query) !== null && _a !== void 0 ? _a : {}, modelName, "query");
    schemaTypes += "}\n";
    schemaTypes += `\nexport type ${modelName}Methods = {\n`;
    schemaTypes += (0, exports.parseFunctions)(schema.methods, modelName, "methods");
    schemaTypes += "}\n";
    schemaTypes += `\nexport type ${modelName}Statics = {\n`;
    schemaTypes += (0, exports.parseFunctions)(schema.statics, modelName, "statics");
    schemaTypes += "}\n\n";
    const modelExtend = `mongoose.Model<${modelName}Document, ${modelName}Queries>`;
    schemaTypes += templates.getModelDocs(modelName);
    schemaTypes += `\nexport type ${modelName}Model = ${modelExtend} & ${modelName}Statics\n\n`;
    schemaTypes += templates.getSchemaDocs(modelName);
    schemaTypes += `\nexport type ${modelName}Schema = mongoose.Schema<${modelName}Document, ${modelName}Model, ${modelName}Methods, ${modelName}Queries>\n\n`;
    return schemaTypes;
};
exports.getSchemaTypes = getSchemaTypes;
// TODO: This should be split up, shouldnt be writing to file and parsing schema simultaneously. Instead parse shema first then write later.
const generateTypes = ({ sourceFile, imports = [], modelsPaths, noMongoose, datesAsStrings }) => {
    const models = (0, utils_1.loadModels)(modelsPaths);
    sourceFile.addStatements((writer) => {
        writer.write(templates.MAIN_HEADER).blankLine();
        // mongoose import
        if (!noMongoose)
            writer.write(templates.MONGOOSE_IMPORT);
        // custom, user-defined imports
        if (imports.length > 0)
            writer.write(imports.join("\n"));
        writer.blankLine();
        // writer.write("if (true)").block(() => {
        //     writer.write("something;");
        // });
        models.forEach((model) => {
            const { modelName, schema } = model;
            // passing modelName causes childSchemas to be processed
            const leanHeader = templates.getLeanDocs(modelName) + `\nexport type ${modelName} = {\n`;
            const leanFooter = "}";
            const parserSchema = new schema_1.ParserSchema({
                mongooseSchema: schema,
                modelName,
                model
            });
            const leanInterfaceStr = parserSchema.generateTemplate({
                isDocument: false,
                noMongoose,
                datesAsStrings,
                header: leanHeader,
                footer: leanFooter
            });
            writer.write(leanInterfaceStr).blankLine();
            // if noMongoose, skip adding document types
            if (noMongoose) {
                return;
            }
            // get type of _id to pass to mongoose.Document
            const _idType = schema.tree._id
                ? (0, utils_1.convertBaseTypeToTs)({
                    key: "_id",
                    val: schema.tree._id,
                    isDocument: true,
                    noMongoose,
                    datesAsStrings
                })
                : "any";
            const mongooseDocExtend = `mongoose.Document<${_idType}, ${modelName}Queries>`;
            let documentInterfaceStr = "";
            documentInterfaceStr += (0, exports.getSchemaTypes)(model);
            const documentHeader = templates.getDocumentDocs(modelName) +
                `\nexport type ${modelName}Document = ${mongooseDocExtend} & ${modelName}Methods & {\n`;
            const documentFooter = "}";
            documentInterfaceStr += parserSchema.generateTemplate({
                isDocument: true,
                noMongoose,
                datesAsStrings,
                header: documentHeader,
                footer: documentFooter
            });
            writer.write(documentInterfaceStr).blankLine();
        });
    });
    return sourceFile;
};
exports.generateTypes = generateTypes;
const saveFile = ({ sourceFile }) => {
    try {
        sourceFile.saveSync();
    }
    catch (err) {
        console.error(err);
        throw err;
    }
};
exports.saveFile = saveFile;
