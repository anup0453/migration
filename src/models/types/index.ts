/* tslint:disable */

/* eslint-disable */
// ######################################## THIS FILE WAS GENERATED BY MONGOOSE-TSGEN ######################################## //
// NOTE: ANY CHANGES MADE WILL BE OVERWRITTEN ON SUBSEQUENT EXECUTIONS OF MONGOOSE-TSGEN.
import mongoose from 'mongoose'

/**
 * Lean version of AgentBindToolDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `AgentDocument.toObject()`.
 * ```
 * const agentObject = agent.toObject();
 * ```
 */
export type AgentBindTool = {
  agentToolApiKey: string
  agentToolName: string
  description: string
  type: 'bing' | 'rag'
  _id: mongoose.Types.ObjectId
}

/**
 * Lean version of AgentDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `AgentDocument.toObject()`. To avoid conflicts with model names, use the type alias `AgentObject`.
 * ```
 * const agentObject = agent.toObject();
 * ```
 */
export type Agent = {
  apiKey: string
  bindTools: AgentBindTool[]
  description: string
  displayName: string
  isActive?: boolean
  iterationLimit: number
  owner: Customer['_id'] | Customer
  settings: {
    agentApiVersion: string
    agentDeploymentName: string
  }
  systemMessage: string
  type: 'react' | 'custom'
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of AgentDocument (type alias of `Agent`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Agent } from "../models"
 * import { AgentObject } from "../interfaces/mongoose.gen.ts"
 *
 * const agentObject: AgentObject = agent.toObject();
 * ```
 */
export type AgentObject = Agent

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type AgentQuery = mongoose.Query<any, AgentDocument, AgentQueries> &
  AgentQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `AgentSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type AgentQueries = {}

export type AgentMethods = {}

export type AgentStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Agent = mongoose.model<AgentDocument, AgentModel>("Agent", AgentSchema);
 * ```
 */
export type AgentModel = mongoose.Model<AgentDocument, AgentQueries> &
  AgentStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Agent schema instances:
 * ```
 * const AgentSchema: AgentSchema = new mongoose.Schema({ ... })
 * ```
 */
export type AgentSchema = mongoose.Schema<
  AgentDocument,
  AgentModel,
  AgentMethods,
  AgentQueries
>

/**
 * Mongoose Subdocument type
 *
 * Type of `AgentDocument["bindTools"]` element.
 */
export type AgentBindToolDocument =
  mongoose.Types.Subdocument<mongoose.Types.ObjectId> & {
    agentToolApiKey: string
    agentToolName: string
    description: string
    type: 'bing' | 'rag'
    _id: mongoose.Types.ObjectId
  }

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Agent = mongoose.model<AgentDocument, AgentModel>("Agent", AgentSchema);
 * ```
 */
export type AgentDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  AgentQueries
> &
  AgentMethods & {
    apiKey: string
    bindTools: mongoose.Types.DocumentArray<AgentBindToolDocument>
    description: string
    displayName: string
    isActive?: boolean
    iterationLimit: number
    owner: CustomerDocument['_id'] | CustomerDocument
    settings: {
      agentApiVersion: string
      agentDeploymentName: string
    }
    systemMessage: string
    type: 'react' | 'custom'
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of ChargeItemDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ChargeDocument.toObject()`.
 * ```
 * const chargeObject = charge.toObject();
 * ```
 */
export type ChargeItem = {
  amount?: number
  chargeType?: 'oneTime' | 'recurring'
  description?: string
  quantity?: number
  type?: string
  _id: mongoose.Types.ObjectId
}

/**
 * Lean version of ChargeDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ChargeDocument.toObject()`. To avoid conflicts with model names, use the type alias `ChargeObject`.
 * ```
 * const chargeObject = charge.toObject();
 * ```
 */
export type Charge = {
  amount?: number
  chargedAt?: Date
  customer: Customer['_id'] | Customer
  from?: Date
  items: ChargeItem[]
  payAsYouGoId?: number
  payAsYouGoStatus?: string
  to?: Date
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of ChargeDocument (type alias of `Charge`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Charge } from "../models"
 * import { ChargeObject } from "../interfaces/mongoose.gen.ts"
 *
 * const chargeObject: ChargeObject = charge.toObject();
 * ```
 */
export type ChargeObject = Charge

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ChargeQuery = mongoose.Query<any, ChargeDocument, ChargeQueries> &
  ChargeQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `ChargeSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ChargeQueries = {}

export type ChargeMethods = {}

export type ChargeStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Charge = mongoose.model<ChargeDocument, ChargeModel>("Charge", ChargeSchema);
 * ```
 */
export type ChargeModel = mongoose.Model<ChargeDocument, ChargeQueries> &
  ChargeStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Charge schema instances:
 * ```
 * const ChargeSchema: ChargeSchema = new mongoose.Schema({ ... })
 * ```
 */
export type ChargeSchema = mongoose.Schema<
  ChargeDocument,
  ChargeModel,
  ChargeMethods,
  ChargeQueries
>

/**
 * Mongoose Subdocument type
 *
 * Type of `ChargeDocument["items"]` element.
 */
export type ChargeItemDocument =
  mongoose.Types.Subdocument<mongoose.Types.ObjectId> & {
    amount?: number
    chargeType?: 'oneTime' | 'recurring'
    description?: string
    quantity?: number
    type?: string
    _id: mongoose.Types.ObjectId
  }

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Charge = mongoose.model<ChargeDocument, ChargeModel>("Charge", ChargeSchema);
 * ```
 */
export type ChargeDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  ChargeQueries
> &
  ChargeMethods & {
    amount?: number
    chargedAt?: Date
    customer: CustomerDocument['_id'] | CustomerDocument
    from?: Date
    items: mongoose.Types.DocumentArray<ChargeItemDocument>
    payAsYouGoId?: number
    payAsYouGoStatus?: string
    to?: Date
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of ChatRequestIncomingTokenCountDetailDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ChatRequestDocument.toObject()`.
 * ```
 * const chatrequestObject = chatrequest.toObject();
 * ```
 */
export type ChatRequestIncomingTokenCountDetail = {
  acceptedPredictionTokens?: number
  reasoningTokens?: number
  audioTokens?: number
  rejectedPredictionTokens?: number
}

/**
 * Lean version of ChatRequestOutgoingTokenCountDetailDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ChatRequestDocument.toObject()`.
 * ```
 * const chatrequestObject = chatrequest.toObject();
 * ```
 */
export type ChatRequestOutgoingTokenCountDetail = {
  audioTokens?: number
  cachedTokens?: number
}

/**
 * Lean version of ChatRequestDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ChatRequestDocument.toObject()`. To avoid conflicts with model names, use the type alias `ChatRequestObject`.
 * ```
 * const chatrequestObject = chatrequest.toObject();
 * ```
 */
export type ChatRequest = {
  calcTotalPrice?: number
  chargedAt?: Date
  customer: Customer['_id'] | Customer
  incomingTokenCount: number
  incomingTokenCountDetails?: ChatRequestIncomingTokenCountDetail
  numRequests?: number
  outgoingTokenCount: number
  outgoingTokenCountDetails?: ChatRequestOutgoingTokenCountDetail
  type?: 'internal' | 'external' | 'plain'
  usedGPTModel: LargeLanguageModelVersion['_id'] | LargeLanguageModelVersion
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of ChatRequestDocument (type alias of `ChatRequest`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { ChatRequest } from "../models"
 * import { ChatRequestObject } from "../interfaces/mongoose.gen.ts"
 *
 * const chatrequestObject: ChatRequestObject = chatrequest.toObject();
 * ```
 */
export type ChatRequestObject = ChatRequest

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ChatRequestQuery = mongoose.Query<
  any,
  ChatRequestDocument,
  ChatRequestQueries
> &
  ChatRequestQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `ChatRequestSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ChatRequestQueries = {}

export type ChatRequestMethods = {}

export type ChatRequestStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const ChatRequest = mongoose.model<ChatRequestDocument, ChatRequestModel>("ChatRequest", ChatRequestSchema);
 * ```
 */
export type ChatRequestModel = mongoose.Model<
  ChatRequestDocument,
  ChatRequestQueries
> &
  ChatRequestStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new ChatRequest schema instances:
 * ```
 * const ChatRequestSchema: ChatRequestSchema = new mongoose.Schema({ ... })
 * ```
 */
export type ChatRequestSchema = mongoose.Schema<
  ChatRequestDocument,
  ChatRequestModel,
  ChatRequestMethods,
  ChatRequestQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const ChatRequest = mongoose.model<ChatRequestDocument, ChatRequestModel>("ChatRequest", ChatRequestSchema);
 * ```
 */
export type ChatRequestIncomingTokenCountDetailDocument =
  mongoose.Document<any> & {
    acceptedPredictionTokens?: number
    reasoningTokens?: number
    audioTokens?: number
    rejectedPredictionTokens?: number
  }

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const ChatRequest = mongoose.model<ChatRequestDocument, ChatRequestModel>("ChatRequest", ChatRequestSchema);
 * ```
 */
export type ChatRequestOutgoingTokenCountDetailDocument =
  mongoose.Document<any> & {
    audioTokens?: number
    cachedTokens?: number
  }

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const ChatRequest = mongoose.model<ChatRequestDocument, ChatRequestModel>("ChatRequest", ChatRequestSchema);
 * ```
 */
export type ChatRequestDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  ChatRequestQueries
> &
  ChatRequestMethods & {
    calcTotalPrice?: number
    chargedAt?: Date
    customer: CustomerDocument['_id'] | CustomerDocument
    incomingTokenCount: number
    incomingTokenCountDetails?: ChatRequestIncomingTokenCountDetailDocument
    numRequests?: number
    outgoingTokenCount: number
    outgoingTokenCountDetails?: ChatRequestOutgoingTokenCountDetailDocument
    type?: 'internal' | 'external' | 'plain'
    usedGPTModel:
      | LargeLanguageModelVersionDocument['_id']
      | LargeLanguageModelVersionDocument
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of CustomChargeDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `CustomChargeDocument.toObject()`. To avoid conflicts with model names, use the type alias `CustomChargeObject`.
 * ```
 * const customchargeObject = customcharge.toObject();
 * ```
 */
export type CustomCharge = {
  calcTotalPrice?: number
  chargeableAt?: Date
  chargedAt?: Date
  customer: Customer['_id'] | Customer
  description?: string
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of CustomChargeDocument (type alias of `CustomCharge`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { CustomCharge } from "../models"
 * import { CustomChargeObject } from "../interfaces/mongoose.gen.ts"
 *
 * const customchargeObject: CustomChargeObject = customcharge.toObject();
 * ```
 */
export type CustomChargeObject = CustomCharge

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type CustomChargeQuery = mongoose.Query<
  any,
  CustomChargeDocument,
  CustomChargeQueries
> &
  CustomChargeQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `CustomChargeSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type CustomChargeQueries = {}

export type CustomChargeMethods = {}

export type CustomChargeStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const CustomCharge = mongoose.model<CustomChargeDocument, CustomChargeModel>("CustomCharge", CustomChargeSchema);
 * ```
 */
export type CustomChargeModel = mongoose.Model<
  CustomChargeDocument,
  CustomChargeQueries
> &
  CustomChargeStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new CustomCharge schema instances:
 * ```
 * const CustomChargeSchema: CustomChargeSchema = new mongoose.Schema({ ... })
 * ```
 */
export type CustomChargeSchema = mongoose.Schema<
  CustomChargeDocument,
  CustomChargeModel,
  CustomChargeMethods,
  CustomChargeQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const CustomCharge = mongoose.model<CustomChargeDocument, CustomChargeModel>("CustomCharge", CustomChargeSchema);
 * ```
 */
export type CustomChargeDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  CustomChargeQueries
> &
  CustomChargeMethods & {
    calcTotalPrice?: number
    chargeableAt?: Date
    chargedAt?: Date
    customer: CustomerDocument['_id'] | CustomerDocument
    description?: string
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of CustomerAiSearchDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `CustomerDocument.toObject()`.
 * ```
 * const customerObject = customer.toObject();
 * ```
 */
export type CustomerAiSearch = {
  apiKey?: string
  datasourceName?: string
  directIndex?: boolean
  endpoint?: string
  indexerName?: string
  indexingStatus?: string
  indexName?: string
  lastIndexing?: Date
  scoringProfile?: string
  skillsetName?:
    | 'embedding-skillset'
    | 'embeddings-relativepath-skillset'
    | 'extract-relative-path'
}

/**
 * Lean version of CustomerApiKeyDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `CustomerDocument.toObject()`.
 * ```
 * const customerObject = customer.toObject();
 * ```
 */
export type CustomerApiKey = {
  description: string
  key: string
  validFrom: Date
  validTo: Date
  _id: mongoose.Types.ObjectId
}

/**
 * Lean version of CustomerArizeSettingDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `CustomerDocument.toObject()`.
 * ```
 * const customerObject = customer.toObject();
 * ```
 */
export type CustomerArizeSetting = {
  apiKey?: string
  projectName?: string
  spaceId?: string
  tracingEnabled: boolean
}

/**
 * Lean version of CustomerBillingDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `CustomerDocument.toObject()`.
 * ```
 * const customerObject = customer.toObject();
 * ```
 */
export type CustomerBilling = {
  orgId?: string
  payAsYouGoId?: number
  position?: string
  psp?: string
  reference?: string
}

/**
 * Lean version of CustomerFrontendSettingFilterButtonDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `CustomerFrontendSettingDocument.toObject()`.
 * ```
 * const customerfrontendsettingObject = customerfrontendsetting.toObject();
 * ```
 */
export type CustomerFrontendSettingFilterButton = {
  displayName: string
  fieldType: 'Default' | 'ChoiceSet'
  filter: string[]
  isMultiSelect?: boolean
  keywords: string[]
  level?: number
  placeholder?: string
}

/**
 * Lean version of CustomerFrontendSettingDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `CustomerDocument.toObject()`.
 * ```
 * const customerObject = customer.toObject();
 * ```
 */
export type CustomerFrontendSetting = {
  filterButtons: CustomerFrontendSettingFilterButton[]
  hintTextButtonText?: string
  historyResetMessage?: string
  termsOfUseText?: string
  welcomeSystemMessage?: string
}

/**
 * Lean version of CustomerIpFilteringSettingDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `CustomerDocument.toObject()`.
 * ```
 * const customerObject = customer.toObject();
 * ```
 */
export type CustomerIpFilteringSetting = {
  blockingMode?: 'block' | 'log'
  isIpFilteringEnabled?: boolean
  whitelistedIpsArray: string[]
}

/**
 * Lean version of CustomerSettingDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `CustomerDocument.toObject()`.
 * ```
 * const customerObject = customer.toObject();
 * ```
 */
export type CustomerSetting = {
  defaultEmbeddingVersion?: string
  defaultGptVersion?: string
  dynamicNActive?: boolean
  frequencyPenalty?: number
  generateSearchQuerySystemMessage?: string
  historyCount?: number
  ignoreOpenAIParamsInBody?: boolean
  includeDateContext?: boolean
  loadBalancerRegion?: 'emea' | 'americas' | 'apac' | 'worldwide' | 'none'
  maxResponseTokens?: number
  presencePenalty?: number
  reactOnUserMessageSystemMessage?: string
  sourceFilterActive?: boolean
  sourceLinkActive?: boolean
  sourceLinkInstructionSystemMessage?: string
  stop: string[]
  summarizeConversationSystemMessage?: string
  temperature?: number
  topN?: number
  topP?: number
  _id: mongoose.Types.ObjectId
}

/**
 * Lean version of CustomerSubscriptionDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `CustomerDocument.toObject()`.
 * ```
 * const customerObject = customer.toObject();
 * ```
 */
export type CustomerSubscription = {
  end?: Date
  isChargeable?: boolean
  lastChargedAt?: Date
  nextChargedAt?: Date
  paused?: boolean
  start?: Date
  type?: Subscription['_id'] | Subscription
}

/**
 * Lean version of CustomerDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `CustomerDocument.toObject()`. To avoid conflicts with model names, use the type alias `CustomerObject`.
 * ```
 * const customerObject = customer.toObject();
 * ```
 */
export type Customer = {
  aiSearch?: CustomerAiSearch
  apiKeys: CustomerApiKey[]
  arizeSettings?: CustomerArizeSetting
  billing?: CustomerBilling
  datasources: (Datasource['_id'] | Datasource)[]
  frontendSettings?: CustomerFrontendSetting
  internalStorage: {
    connectionString?: string
    containerName?: string
  }
  internalTools: (InternalTool['_id'] | InternalTool)[]
  ipFilteringSettings?: CustomerIpFilteringSetting
  isActive?: boolean
  name: string
  settings?: CustomerSetting
  subscription?: CustomerSubscription
  type?: string
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of CustomerDocument (type alias of `Customer`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Customer } from "../models"
 * import { CustomerObject } from "../interfaces/mongoose.gen.ts"
 *
 * const customerObject: CustomerObject = customer.toObject();
 * ```
 */
export type CustomerObject = Customer

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type CustomerQuery = mongoose.Query<
  any,
  CustomerDocument,
  CustomerQueries
> &
  CustomerQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `CustomerSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type CustomerQueries = {}

export type CustomerMethods = {
  verifyApiKey: (this: CustomerDocument, ...args: any[]) => any
}

export type CustomerStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Customer = mongoose.model<CustomerDocument, CustomerModel>("Customer", CustomerSchema);
 * ```
 */
export type CustomerModel = mongoose.Model<CustomerDocument, CustomerQueries> &
  CustomerStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Customer schema instances:
 * ```
 * const CustomerSchema: CustomerSchema = new mongoose.Schema({ ... })
 * ```
 */
export type CustomerSchema = mongoose.Schema<
  CustomerDocument,
  CustomerModel,
  CustomerMethods,
  CustomerQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Customer = mongoose.model<CustomerDocument, CustomerModel>("Customer", CustomerSchema);
 * ```
 */
export type CustomerAiSearchDocument = mongoose.Document<any> & {
  apiKey?: string
  datasourceName?: string
  directIndex?: boolean
  endpoint?: string
  indexerName?: string
  indexingStatus?: string
  indexName?: string
  lastIndexing?: Date
  scoringProfile?: string
  skillsetName?:
    | 'embedding-skillset'
    | 'embeddings-relativepath-skillset'
    | 'extract-relative-path'
}

/**
 * Mongoose Subdocument type
 *
 * Type of `CustomerDocument["apiKeys"]` element.
 */
export type CustomerApiKeyDocument =
  mongoose.Types.Subdocument<mongoose.Types.ObjectId> & {
    description: string
    key: string
    validFrom: Date
    validTo: Date
    _id: mongoose.Types.ObjectId
  }

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Customer = mongoose.model<CustomerDocument, CustomerModel>("Customer", CustomerSchema);
 * ```
 */
export type CustomerArizeSettingDocument = mongoose.Document<any> & {
  apiKey?: string
  projectName?: string
  spaceId?: string
  tracingEnabled: boolean
}

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Customer = mongoose.model<CustomerDocument, CustomerModel>("Customer", CustomerSchema);
 * ```
 */
export type CustomerBillingDocument = mongoose.Document<any> & {
  orgId?: string
  payAsYouGoId?: number
  position?: string
  psp?: string
  reference?: string
}

/**
 * Mongoose Subdocument type
 *
 * Type of `CustomerFrontendSettingDocument["filterButtons"]` element.
 */
export type CustomerFrontendSettingFilterButtonDocument =
  mongoose.Types.Subdocument<any> & {
    displayName: string
    fieldType: 'Default' | 'ChoiceSet'
    filter: mongoose.Types.Array<string>
    isMultiSelect?: boolean
    keywords: mongoose.Types.Array<string>
    level?: number
    placeholder?: string
  }

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Customer = mongoose.model<CustomerDocument, CustomerModel>("Customer", CustomerSchema);
 * ```
 */
export type CustomerFrontendSettingDocument = mongoose.Document<any> & {
  filterButtons: mongoose.Types.DocumentArray<CustomerFrontendSettingFilterButtonDocument>
  hintTextButtonText?: string
  historyResetMessage?: string
  termsOfUseText?: string
  welcomeSystemMessage?: string
}

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Customer = mongoose.model<CustomerDocument, CustomerModel>("Customer", CustomerSchema);
 * ```
 */
export type CustomerIpFilteringSettingDocument = mongoose.Document<any> & {
  blockingMode?: 'block' | 'log'
  isIpFilteringEnabled?: boolean
  whitelistedIpsArray: mongoose.Types.Array<string>
}

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Customer = mongoose.model<CustomerDocument, CustomerModel>("Customer", CustomerSchema);
 * ```
 */
export type CustomerSettingDocument =
  mongoose.Document<mongoose.Types.ObjectId> & {
    defaultEmbeddingVersion?: string
    defaultGptVersion?: string
    dynamicNActive?: boolean
    frequencyPenalty?: number
    generateSearchQuerySystemMessage?: string
    historyCount?: number
    ignoreOpenAIParamsInBody?: boolean
    includeDateContext?: boolean
    loadBalancerRegion?: 'emea' | 'americas' | 'apac' | 'worldwide' | 'none'
    maxResponseTokens?: number
    presencePenalty?: number
    reactOnUserMessageSystemMessage?: string
    sourceFilterActive?: boolean
    sourceLinkActive?: boolean
    sourceLinkInstructionSystemMessage?: string
    stop: mongoose.Types.Array<string>
    summarizeConversationSystemMessage?: string
    temperature?: number
    topN?: number
    topP?: number
    _id: mongoose.Types.ObjectId
  }

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Customer = mongoose.model<CustomerDocument, CustomerModel>("Customer", CustomerSchema);
 * ```
 */
export type CustomerSubscriptionDocument = mongoose.Document<any> & {
  end?: Date
  isChargeable?: boolean
  lastChargedAt?: Date
  nextChargedAt?: Date
  paused?: boolean
  start?: Date
  type?: SubscriptionDocument['_id'] | SubscriptionDocument
}

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Customer = mongoose.model<CustomerDocument, CustomerModel>("Customer", CustomerSchema);
 * ```
 */
export type CustomerDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  CustomerQueries
> &
  CustomerMethods & {
    aiSearch?: CustomerAiSearchDocument
    apiKeys: mongoose.Types.DocumentArray<CustomerApiKeyDocument>
    arizeSettings?: CustomerArizeSettingDocument
    billing?: CustomerBillingDocument
    datasources: mongoose.Types.Array<
      DatasourceDocument['_id'] | DatasourceDocument
    >
    frontendSettings?: CustomerFrontendSettingDocument
    internalStorage: {
      connectionString?: string
      containerName?: string
    }
    internalTools: mongoose.Types.Array<
      InternalToolDocument['_id'] | InternalToolDocument
    >
    ipFilteringSettings?: CustomerIpFilteringSettingDocument
    isActive?: boolean
    name: string
    settings?: CustomerSettingDocument
    subscription?: CustomerSubscriptionDocument
    type?: string
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of DatasourceSettingsAzureBlobStorageDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `DatasourceDocument.toObject()`.
 * ```
 * const datasourceObject = datasource.toObject();
 * ```
 */
export type DatasourceSettingsAzureBlobStorage = {
  blobBaseUrl?: string
  blobSasToken?: string
  connectionString: string
  containerName: string
}

/**
 * Lean version of DatasourceSettingsWebsiteDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `DatasourceDocument.toObject()`.
 * ```
 * const datasourceObject = datasource.toObject();
 * ```
 */
export type DatasourceSettingsWebsite = {
  contentCssSelectors: string[]
  crawlCssSelectors: string[]
  lazyLoadingEnforced?: boolean
  recursionDepth: number
  rootUrls: string[]
  scrollableElementSelector?: string
  urlWhiteList: string[]
}

/**
 * Lean version of DatasourceSettingsSharepointDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `DatasourceDocument.toObject()`.
 * ```
 * const datasourceObject = datasource.toObject();
 * ```
 */
export type DatasourceSettingsSharepoint = {
  elements: ('lists' | 'pages')[]
  pageWhiteList: string[]
  url: string
  whiteList: string[]
}

/**
 * Lean version of DatasourceSettingsPolarionDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `DatasourceDocument.toObject()`.
 * ```
 * const datasourceObject = datasource.toObject();
 * ```
 */
export type DatasourceSettingsPolarion = {
  accessToken: string
  endpoint: string
  fields: string[]
  project: string
  query: string
}

/**
 * Lean version of DatasourceSettingsApiExtraHeaderDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `DatasourceSettingsApiDocument.toObject()`.
 * ```
 * const datasourcesettingsapiObject = datasourcesettingsapi.toObject();
 * ```
 */
export type DatasourceSettingsApiExtraHeader = {
  key: string
  value: string
}

/**
 * Lean version of DatasourceSettingsApiDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `DatasourceDocument.toObject()`.
 * ```
 * const datasourceObject = datasource.toObject();
 * ```
 */
export type DatasourceSettingsApi = {
  authorizationHeader?: string
  endpoint: string
  excludeFields: string[]
  extraHeaders: DatasourceSettingsApiExtraHeader[]
  fileNameField: string
  filePathField?: string
  includeFields: string[]
  payloadField?: string
  updatedAtField?: string
}

/**
 * Lean version of DatasourceSettingsWikiDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `DatasourceDocument.toObject()`.
 * ```
 * const datasourceObject = datasource.toObject();
 * ```
 */
export type DatasourceSettingsWiki = {
  baseUrl: string
}

/**
 * Lean version of DatasourceDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `DatasourceDocument.toObject()`. To avoid conflicts with model names, use the type alias `DatasourceObject`.
 * ```
 * const datasourceObject = datasource.toObject();
 * ```
 */
export type Datasource = {
  chunkingPriority?: number
  consecutiveErrors?: number
  displayName?: string
  forceCleanParsing?: boolean
  frequency?: string
  indexingStatus?:
    | 'priorityRestart'
    | 'queued'
    | 'processing'
    | 'error'
    | 'processed'
  isActive?: boolean
  keywords: string[]
  lastIndexing?: Date
  owner?: Customer['_id'] | Customer
  settings: {
    chunkOverlap?: number
    chunkSize?: number
    defaultLanguage?: string
    delimiters: string[]
    excludeByRegex: string[]
    includeByRegex: string[]
    ocrActive?: boolean
    preventXMLToJSON?: boolean
    sourceLinkActive?: boolean
    textSplitterStrategy?: 'token' | 'delimiter'
    translationActive?: boolean
    useMarkdown?: boolean
    azureBlobStorage?: DatasourceSettingsAzureBlobStorage
    website?: DatasourceSettingsWebsite
    sharepoint?: DatasourceSettingsSharepoint
    polarion?: DatasourceSettingsPolarion
    api?: DatasourceSettingsApi
    wiki?: DatasourceSettingsWiki
  }
  type?:
    | 'azureBlobStorage'
    | 'polarion'
    | 'sharepoint'
    | 'website'
    | 'api'
    | 'wiki'
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of DatasourceDocument (type alias of `Datasource`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Datasource } from "../models"
 * import { DatasourceObject } from "../interfaces/mongoose.gen.ts"
 *
 * const datasourceObject: DatasourceObject = datasource.toObject();
 * ```
 */
export type DatasourceObject = Datasource

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type DatasourceQuery = mongoose.Query<
  any,
  DatasourceDocument,
  DatasourceQueries
> &
  DatasourceQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `DatasourceSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type DatasourceQueries = {}

export type DatasourceMethods = {}

export type DatasourceStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Datasource = mongoose.model<DatasourceDocument, DatasourceModel>("Datasource", DatasourceSchema);
 * ```
 */
export type DatasourceModel = mongoose.Model<
  DatasourceDocument,
  DatasourceQueries
> &
  DatasourceStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Datasource schema instances:
 * ```
 * const DatasourceSchema: DatasourceSchema = new mongoose.Schema({ ... })
 * ```
 */
export type DatasourceSchema = mongoose.Schema<
  DatasourceDocument,
  DatasourceModel,
  DatasourceMethods,
  DatasourceQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Datasource = mongoose.model<DatasourceDocument, DatasourceModel>("Datasource", DatasourceSchema);
 * ```
 */
export type DatasourceSettingsAzureBlobStorageDocument =
  mongoose.Document<any> & {
    blobBaseUrl?: string
    blobSasToken?: string
    connectionString: string
    containerName: string
  }

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Datasource = mongoose.model<DatasourceDocument, DatasourceModel>("Datasource", DatasourceSchema);
 * ```
 */
export type DatasourceSettingsWebsiteDocument = mongoose.Document<any> & {
  contentCssSelectors: mongoose.Types.Array<string>
  crawlCssSelectors: mongoose.Types.Array<string>
  lazyLoadingEnforced?: boolean
  recursionDepth: number
  rootUrls: mongoose.Types.Array<string>
  scrollableElementSelector?: string
  urlWhiteList: mongoose.Types.Array<string>
}

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Datasource = mongoose.model<DatasourceDocument, DatasourceModel>("Datasource", DatasourceSchema);
 * ```
 */
export type DatasourceSettingsSharepointDocument = mongoose.Document<any> & {
  elements: mongoose.Types.Array<'lists' | 'pages'>
  pageWhiteList: mongoose.Types.Array<string>
  url: string
  whiteList: mongoose.Types.Array<string>
}

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Datasource = mongoose.model<DatasourceDocument, DatasourceModel>("Datasource", DatasourceSchema);
 * ```
 */
export type DatasourceSettingsPolarionDocument = mongoose.Document<any> & {
  accessToken: string
  endpoint: string
  fields: mongoose.Types.Array<string>
  project: string
  query: string
}

/**
 * Mongoose Subdocument type
 *
 * Type of `DatasourceSettingsApiDocument["extraHeaders"]` element.
 */
export type DatasourceSettingsApiExtraHeaderDocument =
  mongoose.Types.Subdocument<any> & {
    key: string
    value: string
  }

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Datasource = mongoose.model<DatasourceDocument, DatasourceModel>("Datasource", DatasourceSchema);
 * ```
 */
export type DatasourceSettingsApiDocument = mongoose.Document<any> & {
  authorizationHeader?: string
  endpoint: string
  excludeFields: mongoose.Types.Array<string>
  extraHeaders: mongoose.Types.DocumentArray<DatasourceSettingsApiExtraHeaderDocument>
  fileNameField: string
  filePathField?: string
  includeFields: mongoose.Types.Array<string>
  payloadField?: string
  updatedAtField?: string
}

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Datasource = mongoose.model<DatasourceDocument, DatasourceModel>("Datasource", DatasourceSchema);
 * ```
 */
export type DatasourceSettingsWikiDocument = mongoose.Document<any> & {
  baseUrl: string
}

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Datasource = mongoose.model<DatasourceDocument, DatasourceModel>("Datasource", DatasourceSchema);
 * ```
 */
export type DatasourceDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  DatasourceQueries
> &
  DatasourceMethods & {
    chunkingPriority?: number
    consecutiveErrors?: number
    displayName?: string
    forceCleanParsing?: boolean
    frequency?: string
    indexingStatus?:
      | 'priorityRestart'
      | 'queued'
      | 'processing'
      | 'error'
      | 'processed'
    isActive?: boolean
    keywords: mongoose.Types.Array<string>
    lastIndexing?: Date
    owner?: CustomerDocument['_id'] | CustomerDocument
    settings: {
      chunkOverlap?: number
      chunkSize?: number
      defaultLanguage?: string
      delimiters: mongoose.Types.Array<string>
      excludeByRegex: mongoose.Types.Array<string>
      includeByRegex: mongoose.Types.Array<string>
      ocrActive?: boolean
      preventXMLToJSON?: boolean
      sourceLinkActive?: boolean
      textSplitterStrategy?: 'token' | 'delimiter'
      translationActive?: boolean
      useMarkdown?: boolean
      azureBlobStorage?: DatasourceSettingsAzureBlobStorageDocument
      website?: DatasourceSettingsWebsiteDocument
      sharepoint?: DatasourceSettingsSharepointDocument
      polarion?: DatasourceSettingsPolarionDocument
      api?: DatasourceSettingsApiDocument
      wiki?: DatasourceSettingsWikiDocument
    }
    type?:
      | 'azureBlobStorage'
      | 'polarion'
      | 'sharepoint'
      | 'website'
      | 'api'
      | 'wiki'
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of EmbeddingDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `EmbeddingDocument.toObject()`. To avoid conflicts with model names, use the type alias `EmbeddingObject`.
 * ```
 * const embeddingObject = embedding.toObject();
 * ```
 */
export type Embedding = {
  calcTotalPrice: number
  chargedAt?: Date
  customer: Customer['_id'] | Customer
  incomingTokenCount: number
  numRequests?: number
  type?: 'indexation' | 'request' | 'manual' | 'plain'
  usedModel: EmbeddingModelVersion['_id'] | EmbeddingModelVersion
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of EmbeddingDocument (type alias of `Embedding`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Embedding } from "../models"
 * import { EmbeddingObject } from "../interfaces/mongoose.gen.ts"
 *
 * const embeddingObject: EmbeddingObject = embedding.toObject();
 * ```
 */
export type EmbeddingObject = Embedding

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type EmbeddingQuery = mongoose.Query<
  any,
  EmbeddingDocument,
  EmbeddingQueries
> &
  EmbeddingQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `EmbeddingSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type EmbeddingQueries = {}

export type EmbeddingMethods = {}

export type EmbeddingStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Embedding = mongoose.model<EmbeddingDocument, EmbeddingModel>("Embedding", EmbeddingSchema);
 * ```
 */
export type EmbeddingModel = mongoose.Model<
  EmbeddingDocument,
  EmbeddingQueries
> &
  EmbeddingStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Embedding schema instances:
 * ```
 * const EmbeddingSchema: EmbeddingSchema = new mongoose.Schema({ ... })
 * ```
 */
export type EmbeddingSchema = mongoose.Schema<
  EmbeddingDocument,
  EmbeddingModel,
  EmbeddingMethods,
  EmbeddingQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Embedding = mongoose.model<EmbeddingDocument, EmbeddingModel>("Embedding", EmbeddingSchema);
 * ```
 */
export type EmbeddingDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  EmbeddingQueries
> &
  EmbeddingMethods & {
    calcTotalPrice: number
    chargedAt?: Date
    customer: CustomerDocument['_id'] | CustomerDocument
    incomingTokenCount: number
    numRequests?: number
    type?: 'indexation' | 'request' | 'manual' | 'plain'
    usedModel:
      | EmbeddingModelVersionDocument['_id']
      | EmbeddingModelVersionDocument
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of EmbeddingModelVersionDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `EmbeddingModelVersionDocument.toObject()`. To avoid conflicts with model names, use the type alias `EmbeddingModelVersionObject`.
 * ```
 * const embeddingmodelversionObject = embeddingmodelversion.toObject();
 * ```
 */
export type EmbeddingModelVersion = {
  description?: string
  name: string
  pricePerToken: number
  validFrom?: Date
  validUntil?: Date
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of EmbeddingModelVersionDocument (type alias of `EmbeddingModelVersion`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { EmbeddingModelVersion } from "../models"
 * import { EmbeddingModelVersionObject } from "../interfaces/mongoose.gen.ts"
 *
 * const embeddingmodelversionObject: EmbeddingModelVersionObject = embeddingmodelversion.toObject();
 * ```
 */
export type EmbeddingModelVersionObject = EmbeddingModelVersion

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type EmbeddingModelVersionQuery = mongoose.Query<
  any,
  EmbeddingModelVersionDocument,
  EmbeddingModelVersionQueries
> &
  EmbeddingModelVersionQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `EmbeddingModelVersionSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type EmbeddingModelVersionQueries = {}

export type EmbeddingModelVersionMethods = {}

export type EmbeddingModelVersionStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const EmbeddingModelVersion = mongoose.model<EmbeddingModelVersionDocument, EmbeddingModelVersionModel>("EmbeddingModelVersion", EmbeddingModelVersionSchema);
 * ```
 */
export type EmbeddingModelVersionModel = mongoose.Model<
  EmbeddingModelVersionDocument,
  EmbeddingModelVersionQueries
> &
  EmbeddingModelVersionStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new EmbeddingModelVersion schema instances:
 * ```
 * const EmbeddingModelVersionSchema: EmbeddingModelVersionSchema = new mongoose.Schema({ ... })
 * ```
 */
export type EmbeddingModelVersionSchema = mongoose.Schema<
  EmbeddingModelVersionDocument,
  EmbeddingModelVersionModel,
  EmbeddingModelVersionMethods,
  EmbeddingModelVersionQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const EmbeddingModelVersion = mongoose.model<EmbeddingModelVersionDocument, EmbeddingModelVersionModel>("EmbeddingModelVersion", EmbeddingModelVersionSchema);
 * ```
 */
export type EmbeddingModelVersionDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  EmbeddingModelVersionQueries
> &
  EmbeddingModelVersionMethods & {
    description?: string
    name: string
    pricePerToken: number
    validFrom?: Date
    validUntil?: Date
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of ImportDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ImportDocument.toObject()`. To avoid conflicts with model names, use the type alias `ImportObject`.
 * ```
 * const importObject = import.toObject();
 * ```
 */
export type Import = {
  archiveDate?: Date
  azureFileId?: string
  chunkFiles: string[]
  contentHash?: string
  datasource?: Datasource['_id'] | Datasource
  extractedAt?: Date
  extractionLog?: string
  fileName: string
  filePath?: string
  index?: string
  isArchived?: boolean
  mimeType?: string
  status?:
    | 'pending'
    | 'uploaded'
    | 'training'
    | 'trained'
    | 'removed'
    | 'untraining'
    | 'untrained'
    | 'failed'
  type?: 'website' | 'file'
  uploadType?: 'manual' | 'pipeline' | 'crawler'
  urlFileName?: string
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of ImportDocument (type alias of `Import`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Import } from "../models"
 * import { ImportObject } from "../interfaces/mongoose.gen.ts"
 *
 * const importObject: ImportObject = import.toObject();
 * ```
 */
export type ImportObject = Import

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ImportQuery = mongoose.Query<any, ImportDocument, ImportQueries> &
  ImportQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `ImportSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ImportQueries = {}

export type ImportMethods = {}

export type ImportStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Import = mongoose.model<ImportDocument, ImportModel>("Import", ImportSchema);
 * ```
 */
export type ImportModel = mongoose.Model<ImportDocument, ImportQueries> &
  ImportStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Import schema instances:
 * ```
 * const ImportSchema: ImportSchema = new mongoose.Schema({ ... })
 * ```
 */
export type ImportSchema = mongoose.Schema<
  ImportDocument,
  ImportModel,
  ImportMethods,
  ImportQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Import = mongoose.model<ImportDocument, ImportModel>("Import", ImportSchema);
 * ```
 */
export type ImportDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  ImportQueries
> &
  ImportMethods & {
    archiveDate?: Date
    azureFileId?: string
    chunkFiles: mongoose.Types.Array<string>
    contentHash?: string
    datasource?: DatasourceDocument['_id'] | DatasourceDocument
    extractedAt?: Date
    extractionLog?: string
    fileName: string
    filePath?: string
    index?: string
    isArchived?: boolean
    mimeType?: string
    status?:
      | 'pending'
      | 'uploaded'
      | 'training'
      | 'trained'
      | 'removed'
      | 'untraining'
      | 'untrained'
      | 'failed'
    type?: 'website' | 'file'
    uploadType?: 'manual' | 'pipeline' | 'crawler'
    urlFileName?: string
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of InternalToolSettingsBingSearchDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `InternalToolDocument.toObject()`.
 * ```
 * const internaltoolObject = internaltool.toObject();
 * ```
 */
export type InternalToolSettingsBingSearch = {
  language: string
  numberRecords: number
}

/**
 * Lean version of InternalToolSettingsSnowflakeDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `InternalToolDocument.toObject()`.
 * ```
 * const internaltoolObject = internaltool.toObject();
 * ```
 */
export type InternalToolSettingsSnowflake = {
  account: string
  customerPrivateKey: string
  database: string
  passphrase: string
  role: string
  table: string[]
  username: string
  warehouse: string
}

/**
 * Lean version of InternalToolDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `InternalToolDocument.toObject()`. To avoid conflicts with model names, use the type alias `InternalToolObject`.
 * ```
 * const internaltoolObject = internaltool.toObject();
 * ```
 */
export type InternalTool = {
  description?: string
  displayName?: string
  isActive?: boolean
  owner?: Customer['_id'] | Customer
  settings: {
    bingSearch?: InternalToolSettingsBingSearch
    snowflake?: InternalToolSettingsSnowflake
  }
  type?: 'bingSearch' | 'snowflake'
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of InternalToolDocument (type alias of `InternalTool`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { InternalTool } from "../models"
 * import { InternalToolObject } from "../interfaces/mongoose.gen.ts"
 *
 * const internaltoolObject: InternalToolObject = internaltool.toObject();
 * ```
 */
export type InternalToolObject = InternalTool

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type InternalToolQuery = mongoose.Query<
  any,
  InternalToolDocument,
  InternalToolQueries
> &
  InternalToolQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `InternalToolSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type InternalToolQueries = {}

export type InternalToolMethods = {}

export type InternalToolStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const InternalTool = mongoose.model<InternalToolDocument, InternalToolModel>("InternalTool", InternalToolSchema);
 * ```
 */
export type InternalToolModel = mongoose.Model<
  InternalToolDocument,
  InternalToolQueries
> &
  InternalToolStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new InternalTool schema instances:
 * ```
 * const InternalToolSchema: InternalToolSchema = new mongoose.Schema({ ... })
 * ```
 */
export type InternalToolSchema = mongoose.Schema<
  InternalToolDocument,
  InternalToolModel,
  InternalToolMethods,
  InternalToolQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const InternalTool = mongoose.model<InternalToolDocument, InternalToolModel>("InternalTool", InternalToolSchema);
 * ```
 */
export type InternalToolSettingsBingSearchDocument = mongoose.Document<any> & {
  language: string
  numberRecords: number
}

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const InternalTool = mongoose.model<InternalToolDocument, InternalToolModel>("InternalTool", InternalToolSchema);
 * ```
 */
export type InternalToolSettingsSnowflakeDocument = mongoose.Document<any> & {
  account: string
  customerPrivateKey: string
  database: string
  passphrase: string
  role: string
  table: mongoose.Types.Array<string>
  username: string
  warehouse: string
}

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const InternalTool = mongoose.model<InternalToolDocument, InternalToolModel>("InternalTool", InternalToolSchema);
 * ```
 */
export type InternalToolDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  InternalToolQueries
> &
  InternalToolMethods & {
    description?: string
    displayName?: string
    isActive?: boolean
    owner?: CustomerDocument['_id'] | CustomerDocument
    settings: {
      bingSearch?: InternalToolSettingsBingSearchDocument
      snowflake?: InternalToolSettingsSnowflakeDocument
    }
    type?: 'bingSearch' | 'snowflake'
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of InternalToolCallDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `InternalToolCallDocument.toObject()`. To avoid conflicts with model names, use the type alias `InternalToolCallObject`.
 * ```
 * const internaltoolcallObject = internaltoolcall.toObject();
 * ```
 */
export type InternalToolCall = {
  calcTotalPrice?: number
  chargedAt?: Date
  numRequests: number
  customer: Customer['_id'] | Customer
  internalTool?: Datasource['_id'] | Datasource
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of InternalToolCallDocument (type alias of `InternalToolCall`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { InternalToolCall } from "../models"
 * import { InternalToolCallObject } from "../interfaces/mongoose.gen.ts"
 *
 * const internaltoolcallObject: InternalToolCallObject = internaltoolcall.toObject();
 * ```
 */
export type InternalToolCallObject = InternalToolCall

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type InternalToolCallQuery = mongoose.Query<
  any,
  InternalToolCallDocument,
  InternalToolCallQueries
> &
  InternalToolCallQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `InternalToolCallSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type InternalToolCallQueries = {}

export type InternalToolCallMethods = {}

export type InternalToolCallStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const InternalToolCall = mongoose.model<InternalToolCallDocument, InternalToolCallModel>("InternalToolCall", InternalToolCallSchema);
 * ```
 */
export type InternalToolCallModel = mongoose.Model<
  InternalToolCallDocument,
  InternalToolCallQueries
> &
  InternalToolCallStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new InternalToolCall schema instances:
 * ```
 * const InternalToolCallSchema: InternalToolCallSchema = new mongoose.Schema({ ... })
 * ```
 */
export type InternalToolCallSchema = mongoose.Schema<
  InternalToolCallDocument,
  InternalToolCallModel,
  InternalToolCallMethods,
  InternalToolCallQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const InternalToolCall = mongoose.model<InternalToolCallDocument, InternalToolCallModel>("InternalToolCall", InternalToolCallSchema);
 * ```
 */
export type InternalToolCallDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  InternalToolCallQueries
> &
  InternalToolCallMethods & {
    calcTotalPrice?: number
    chargedAt?: Date
    numRequests: number
    customer: CustomerDocument['_id'] | CustomerDocument
    internalTool?: DatasourceDocument['_id'] | DatasourceDocument
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of LargeLanguageModelVersionDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `LargeLanguageModelVersionDocument.toObject()`. To avoid conflicts with model names, use the type alias `LargeLanguageModelVersionObject`.
 * ```
 * const largelanguagemodelversionObject = largelanguagemodelversion.toObject();
 * ```
 */
export type LargeLanguageModelVersion = {
  description?: string
  maxTokens?: number
  name: string
  pricePerIncomingToken: number
  pricePerOutgoingToken: number
  pricePerCachedOutgoingToken: number
  validFrom?: Date
  validUntil?: Date
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of LargeLanguageModelVersionDocument (type alias of `LargeLanguageModelVersion`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { LargeLanguageModelVersion } from "../models"
 * import { LargeLanguageModelVersionObject } from "../interfaces/mongoose.gen.ts"
 *
 * const largelanguagemodelversionObject: LargeLanguageModelVersionObject = largelanguagemodelversion.toObject();
 * ```
 */
export type LargeLanguageModelVersionObject = LargeLanguageModelVersion

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type LargeLanguageModelVersionQuery = mongoose.Query<
  any,
  LargeLanguageModelVersionDocument,
  LargeLanguageModelVersionQueries
> &
  LargeLanguageModelVersionQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `LargeLanguageModelVersionSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type LargeLanguageModelVersionQueries = {}

export type LargeLanguageModelVersionMethods = {}

export type LargeLanguageModelVersionStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const LargeLanguageModelVersion = mongoose.model<LargeLanguageModelVersionDocument, LargeLanguageModelVersionModel>("LargeLanguageModelVersion", LargeLanguageModelVersionSchema);
 * ```
 */
export type LargeLanguageModelVersionModel = mongoose.Model<
  LargeLanguageModelVersionDocument,
  LargeLanguageModelVersionQueries
> &
  LargeLanguageModelVersionStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new LargeLanguageModelVersion schema instances:
 * ```
 * const LargeLanguageModelVersionSchema: LargeLanguageModelVersionSchema = new mongoose.Schema({ ... })
 * ```
 */
export type LargeLanguageModelVersionSchema = mongoose.Schema<
  LargeLanguageModelVersionDocument,
  LargeLanguageModelVersionModel,
  LargeLanguageModelVersionMethods,
  LargeLanguageModelVersionQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const LargeLanguageModelVersion = mongoose.model<LargeLanguageModelVersionDocument, LargeLanguageModelVersionModel>("LargeLanguageModelVersion", LargeLanguageModelVersionSchema);
 * ```
 */
export type LargeLanguageModelVersionDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  LargeLanguageModelVersionQueries
> &
  LargeLanguageModelVersionMethods & {
    description?: string
    maxTokens?: number
    name: string
    pricePerIncomingToken: number
    pricePerOutgoingToken: number
    pricePerCachedOutgoingToken: number
    validFrom?: Date
    validUntil?: Date
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of MigrationDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `MigrationDocument.toObject()`. To avoid conflicts with model names, use the type alias `MigrationObject`.
 * ```
 * const migrationObject = migration.toObject();
 * ```
 */
export type Migration = {
  indexName?: string
  name: string
  object?: mongoose.Types.ObjectId
  status: 'running' | 'completed' | 'failed'
  type: 'AI SEARCH' | 'DATABASE'
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of MigrationDocument (type alias of `Migration`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Migration } from "../models"
 * import { MigrationObject } from "../interfaces/mongoose.gen.ts"
 *
 * const migrationObject: MigrationObject = migration.toObject();
 * ```
 */
export type MigrationObject = Migration

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type MigrationQuery = mongoose.Query<
  any,
  MigrationDocument,
  MigrationQueries
> &
  MigrationQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `MigrationSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type MigrationQueries = {}

export type MigrationMethods = {}

export type MigrationStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Migration = mongoose.model<MigrationDocument, MigrationModel>("Migration", MigrationSchema);
 * ```
 */
export type MigrationModel = mongoose.Model<
  MigrationDocument,
  MigrationQueries
> &
  MigrationStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Migration schema instances:
 * ```
 * const MigrationSchema: MigrationSchema = new mongoose.Schema({ ... })
 * ```
 */
export type MigrationSchema = mongoose.Schema<
  MigrationDocument,
  MigrationModel,
  MigrationMethods,
  MigrationQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Migration = mongoose.model<MigrationDocument, MigrationModel>("Migration", MigrationSchema);
 * ```
 */
export type MigrationDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  MigrationQueries
> &
  MigrationMethods & {
    indexName?: string
    name: string
    object?: mongoose.Types.ObjectId
    status: 'running' | 'completed' | 'failed'
    type: 'AI SEARCH' | 'DATABASE'
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of ModelDeploymentDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ModelDeploymentDocument.toObject()`. To avoid conflicts with model names, use the type alias `ModelDeploymentObject`.
 * ```
 * const modeldeploymentObject = modeldeployment.toObject();
 * ```
 */
export type ModelDeployment = {
  deploymentName: string
  endpoint: string
  instanceName: string
  isPTU: boolean
  key: string
  modelName: string
  modelVersion: string
  openAiVersion: string
  region: 'emea' | 'americas' | 'apac' | 'worldwide' | 'none'
  type: 'embedding' | 'llm'
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of ModelDeploymentDocument (type alias of `ModelDeployment`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { ModelDeployment } from "../models"
 * import { ModelDeploymentObject } from "../interfaces/mongoose.gen.ts"
 *
 * const modeldeploymentObject: ModelDeploymentObject = modeldeployment.toObject();
 * ```
 */
export type ModelDeploymentObject = ModelDeployment

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ModelDeploymentQuery = mongoose.Query<
  any,
  ModelDeploymentDocument,
  ModelDeploymentQueries
> &
  ModelDeploymentQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `ModelDeploymentSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ModelDeploymentQueries = {}

export type ModelDeploymentMethods = {}

export type ModelDeploymentStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const ModelDeployment = mongoose.model<ModelDeploymentDocument, ModelDeploymentModel>("ModelDeployment", ModelDeploymentSchema);
 * ```
 */
export type ModelDeploymentModel = mongoose.Model<
  ModelDeploymentDocument,
  ModelDeploymentQueries
> &
  ModelDeploymentStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new ModelDeployment schema instances:
 * ```
 * const ModelDeploymentSchema: ModelDeploymentSchema = new mongoose.Schema({ ... })
 * ```
 */
export type ModelDeploymentSchema = mongoose.Schema<
  ModelDeploymentDocument,
  ModelDeploymentModel,
  ModelDeploymentMethods,
  ModelDeploymentQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const ModelDeployment = mongoose.model<ModelDeploymentDocument, ModelDeploymentModel>("ModelDeployment", ModelDeploymentSchema);
 * ```
 */
export type ModelDeploymentDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  ModelDeploymentQueries
> &
  ModelDeploymentMethods & {
    deploymentName: string
    endpoint: string
    instanceName: string
    isPTU: boolean
    key: string
    modelName: string
    modelVersion: string
    openAiVersion: string
    region: 'emea' | 'americas' | 'apac' | 'worldwide' | 'none'
    type: 'embedding' | 'llm'
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of SubscriptionDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `SubscriptionDocument.toObject()`. To avoid conflicts with model names, use the type alias `SubscriptionObject`.
 * ```
 * const subscriptionObject = subscription.toObject();
 * ```
 */
export type Subscription = {
  amount?: number
  isActive?: boolean
  isDefault?: boolean
  name: string
  periodInMonths?: number
  validFrom?: Date
  validTo?: Date
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of SubscriptionDocument (type alias of `Subscription`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Subscription } from "../models"
 * import { SubscriptionObject } from "../interfaces/mongoose.gen.ts"
 *
 * const subscriptionObject: SubscriptionObject = subscription.toObject();
 * ```
 */
export type SubscriptionObject = Subscription

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type SubscriptionQuery = mongoose.Query<
  any,
  SubscriptionDocument,
  SubscriptionQueries
> &
  SubscriptionQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `SubscriptionSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type SubscriptionQueries = {}

export type SubscriptionMethods = {}

export type SubscriptionStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Subscription = mongoose.model<SubscriptionDocument, SubscriptionModel>("Subscription", SubscriptionSchema);
 * ```
 */
export type SubscriptionModel = mongoose.Model<
  SubscriptionDocument,
  SubscriptionQueries
> &
  SubscriptionStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Subscription schema instances:
 * ```
 * const SubscriptionSchema: SubscriptionSchema = new mongoose.Schema({ ... })
 * ```
 */
export type SubscriptionSchema = mongoose.Schema<
  SubscriptionDocument,
  SubscriptionModel,
  SubscriptionMethods,
  SubscriptionQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Subscription = mongoose.model<SubscriptionDocument, SubscriptionModel>("Subscription", SubscriptionSchema);
 * ```
 */
export type SubscriptionDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  SubscriptionQueries
> &
  SubscriptionMethods & {
    amount?: number
    isActive?: boolean
    isDefault?: boolean
    name: string
    periodInMonths?: number
    validFrom?: Date
    validTo?: Date
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of TranslationDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `TranslationDocument.toObject()`. To avoid conflicts with model names, use the type alias `TranslationObject`.
 * ```
 * const translationObject = translation.toObject();
 * ```
 */
export type Translation = {
  calcTotalPrice?: number
  characterCount: number
  chargedAt?: Date
  costType?: 'translation' | 'detection'
  customer: Customer['_id'] | Customer
  datasource: Datasource['_id'] | Datasource
  import: Import['_id'] | Import
  sourceLanguage?: string
  targetLanguage?: string
  usedModel: TranslationModelVersion['_id'] | TranslationModelVersion
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of TranslationDocument (type alias of `Translation`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Translation } from "../models"
 * import { TranslationObject } from "../interfaces/mongoose.gen.ts"
 *
 * const translationObject: TranslationObject = translation.toObject();
 * ```
 */
export type TranslationObject = Translation

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type TranslationQuery = mongoose.Query<
  any,
  TranslationDocument,
  TranslationQueries
> &
  TranslationQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `TranslationSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type TranslationQueries = {}

export type TranslationMethods = {}

export type TranslationStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Translation = mongoose.model<TranslationDocument, TranslationModel>("Translation", TranslationSchema);
 * ```
 */
export type TranslationModel = mongoose.Model<
  TranslationDocument,
  TranslationQueries
> &
  TranslationStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Translation schema instances:
 * ```
 * const TranslationSchema: TranslationSchema = new mongoose.Schema({ ... })
 * ```
 */
export type TranslationSchema = mongoose.Schema<
  TranslationDocument,
  TranslationModel,
  TranslationMethods,
  TranslationQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Translation = mongoose.model<TranslationDocument, TranslationModel>("Translation", TranslationSchema);
 * ```
 */
export type TranslationDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  TranslationQueries
> &
  TranslationMethods & {
    calcTotalPrice?: number
    characterCount: number
    chargedAt?: Date
    costType?: 'translation' | 'detection'
    customer: CustomerDocument['_id'] | CustomerDocument
    datasource: DatasourceDocument['_id'] | DatasourceDocument
    import: ImportDocument['_id'] | ImportDocument
    sourceLanguage?: string
    targetLanguage?: string
    usedModel:
      | TranslationModelVersionDocument['_id']
      | TranslationModelVersionDocument
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of TranslationModelVersionDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `TranslationModelVersionDocument.toObject()`. To avoid conflicts with model names, use the type alias `TranslationModelVersionObject`.
 * ```
 * const translationmodelversionObject = translationmodelversion.toObject();
 * ```
 */
export type TranslationModelVersion = {
  description?: string
  name: string
  pricePerCharacter: number
  validFrom?: Date
  validUntil?: Date
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of TranslationModelVersionDocument (type alias of `TranslationModelVersion`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { TranslationModelVersion } from "../models"
 * import { TranslationModelVersionObject } from "../interfaces/mongoose.gen.ts"
 *
 * const translationmodelversionObject: TranslationModelVersionObject = translationmodelversion.toObject();
 * ```
 */
export type TranslationModelVersionObject = TranslationModelVersion

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type TranslationModelVersionQuery = mongoose.Query<
  any,
  TranslationModelVersionDocument,
  TranslationModelVersionQueries
> &
  TranslationModelVersionQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `TranslationModelVersionSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type TranslationModelVersionQueries = {}

export type TranslationModelVersionMethods = {}

export type TranslationModelVersionStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const TranslationModelVersion = mongoose.model<TranslationModelVersionDocument, TranslationModelVersionModel>("TranslationModelVersion", TranslationModelVersionSchema);
 * ```
 */
export type TranslationModelVersionModel = mongoose.Model<
  TranslationModelVersionDocument,
  TranslationModelVersionQueries
> &
  TranslationModelVersionStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new TranslationModelVersion schema instances:
 * ```
 * const TranslationModelVersionSchema: TranslationModelVersionSchema = new mongoose.Schema({ ... })
 * ```
 */
export type TranslationModelVersionSchema = mongoose.Schema<
  TranslationModelVersionDocument,
  TranslationModelVersionModel,
  TranslationModelVersionMethods,
  TranslationModelVersionQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const TranslationModelVersion = mongoose.model<TranslationModelVersionDocument, TranslationModelVersionModel>("TranslationModelVersion", TranslationModelVersionSchema);
 * ```
 */
export type TranslationModelVersionDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  TranslationModelVersionQueries
> &
  TranslationModelVersionMethods & {
    description?: string
    name: string
    pricePerCharacter: number
    validFrom?: Date
    validUntil?: Date
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Lean version of UserDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `UserDocument.toObject()`. To avoid conflicts with model names, use the type alias `UserObject`.
 * ```
 * const userObject = user.toObject();
 * ```
 */
export type User = {
  apiKey?: string
  departments: string[]
  email: string
  firstname?: string
  isActive?: boolean
  lastname?: string
  role?: string
  _id: mongoose.Types.ObjectId
  createdAt?: Date
  updatedAt?: Date
}

/**
 * Lean version of UserDocument (type alias of `User`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { User } from "../models"
 * import { UserObject } from "../interfaces/mongoose.gen.ts"
 *
 * const userObject: UserObject = user.toObject();
 * ```
 */
export type UserObject = User

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type UserQuery = mongoose.Query<any, UserDocument, UserQueries> &
  UserQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `UserSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type UserQueries = {}

export type UserMethods = {
  verifyApiKey: (this: UserDocument, ...args: any[]) => any
}

export type UserStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const User = mongoose.model<UserDocument, UserModel>("User", UserSchema);
 * ```
 */
export type UserModel = mongoose.Model<UserDocument, UserQueries> & UserStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new User schema instances:
 * ```
 * const UserSchema: UserSchema = new mongoose.Schema({ ... })
 * ```
 */
export type UserSchema = mongoose.Schema<
  UserDocument,
  UserModel,
  UserMethods,
  UserQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const User = mongoose.model<UserDocument, UserModel>("User", UserSchema);
 * ```
 */
export type UserDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  UserQueries
> &
  UserMethods & {
    apiKey?: string
    departments: mongoose.Types.Array<string>
    email: string
    firstname?: string
    isActive?: boolean
    lastname?: string
    role?: string
    _id: mongoose.Types.ObjectId
    createdAt?: Date
    updatedAt?: Date
  }

/**
 * Check if a property on a document is populated:
 * ```
 * import { IsPopulated } from "../interfaces/mongoose.gen.ts"
 *
 * if (IsPopulated<UserDocument["bestFriend"]>) { ... }
 * ```
 */
export function IsPopulated<T>(doc: T | mongoose.Types.ObjectId): doc is T {
  return doc instanceof mongoose.Document
}

/**
 * Helper type used by `PopulatedDocument`. Returns the parent property of a string
 * representing a nested property (i.e. `friend.user` -> `friend`)
 */
type ParentProperty<T> = T extends `${infer P}.${string}` ? P : never

/**
 * Helper type used by `PopulatedDocument`. Returns the child property of a string
 * representing a nested property (i.e. `friend.user` -> `user`).
 */
type ChildProperty<T> = T extends `${string}.${infer C}` ? C : never

/**
 * Helper type used by `PopulatedDocument`. Removes the `ObjectId` from the general union type generated
 * for ref documents (i.e. `mongoose.Types.ObjectId | UserDocument` -> `UserDocument`)
 */
type PopulatedProperty<Root, T extends keyof Root> = Omit<Root, T> & {
  [ref in T]: Root[T] extends mongoose.Types.Array<infer U>
    ? mongoose.Types.Array<Exclude<U, mongoose.Types.ObjectId>>
    : Exclude<Root[T], mongoose.Types.ObjectId>
}

/**
 * Populate properties on a document type:
 * ```
 * import { PopulatedDocument } from "../interfaces/mongoose.gen.ts"
 *
 * function example(user: PopulatedDocument<UserDocument, "bestFriend">) {
 *   console.log(user.bestFriend._id) // typescript knows this is populated
 * }
 * ```
 */
export type PopulatedDocument<DocType, T> = T extends keyof DocType
  ? PopulatedProperty<DocType, T>
  : ParentProperty<T> extends keyof DocType
  ? Omit<DocType, ParentProperty<T>> & {
      [ref in ParentProperty<T>]: DocType[ParentProperty<T>] extends mongoose.Types.Array<
        infer U
      >
        ? mongoose.Types.Array<
            ChildProperty<T> extends keyof U
              ? PopulatedProperty<U, ChildProperty<T>>
              : PopulatedDocument<U, ChildProperty<T>>
          >
        : ChildProperty<T> extends keyof DocType[ParentProperty<T>]
        ? PopulatedProperty<DocType[ParentProperty<T>], ChildProperty<T>>
        : PopulatedDocument<DocType[ParentProperty<T>], ChildProperty<T>>
    }
  : DocType

/**
 * Helper types used by the populate overloads
 */
type Unarray<T> = T extends Array<infer U> ? U : T
type Modify<T, R> = Omit<T, keyof R> & R

/**
 * Augment mongoose with Query.populate overloads
 */
declare module 'mongoose' {
  interface Query<ResultType, DocType, THelpers = {}> {
    populate<T extends string>(
      path: T,
      select?: string | any,
      model?: string | Model<any, THelpers>,
      match?: any,
    ): Query<
      ResultType extends Array<DocType>
        ? Array<PopulatedDocument<Unarray<ResultType>, T>>
        : ResultType extends DocType
        ? PopulatedDocument<Unarray<ResultType>, T>
        : ResultType,
      DocType,
      THelpers
    > &
      THelpers

    populate<T extends string>(
      options: Modify<PopulateOptions, { path: T }> | Array<PopulateOptions>,
    ): Query<
      ResultType extends Array<DocType>
        ? Array<PopulatedDocument<Unarray<ResultType>, T>>
        : ResultType extends DocType
        ? PopulatedDocument<Unarray<ResultType>, T>
        : ResultType,
      DocType,
      THelpers
    > &
      THelpers
  }
}
